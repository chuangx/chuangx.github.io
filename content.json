{"meta":{"title":"xstudio","subtitle":null,"description":null,"author":"chuangx","url":"https://github.com/chuangx","root":"/"},"pages":[],"posts":[{"title":"Embracing Kotlin - from java/android","slug":"Embracing-kotlin","date":"2019-05-02T17:29:38.000Z","updated":"2019-05-20T05:37:24.817Z","comments":true,"path":"2019/05/03/Embracing-kotlin/","link":"","permalink":"https://github.com/chuangx/2019/05/03/Embracing-kotlin/","excerpt":"When starting a new demo or toy project on android, kotlin becomes my go-to language. It has evolved a lot since 2017 when google makes it as first-class language for writing android apps. It has now stable coroutines in v1.3, kotlin native in beta, multi-platform supports, etc. You can definitely see where it‚Äôs trying to move to ;) As an android developer (for about 70% time), here are the things I love about kotlin.","text":"When starting a new demo or toy project on android, kotlin becomes my go-to language. It has evolved a lot since 2017 when google makes it as first-class language for writing android apps. It has now stable coroutines in v1.3, kotlin native in beta, multi-platform supports, etc. You can definitely see where it‚Äôs trying to move to ;) As an android developer (for about 70% time), here are the things I love about kotlin. Concise &amp; readable as a blockLet‚Äôs start demo by creating a notification channel for music playing service. Typical java version 12345678910NotificationManager notificationManager = (NotificationManager) getSystemService(Service.NOTIFICATION_SERVICE);if (notificationManager != null) &#123; NotificationChannel channel = new NotificationChannel(CHANNEL_ID, CHANNEL_NAME, NotificationManager.IMPORTANCE_DEFAULT); channel.enableLights(true); channel.setName(\"uptown\"); channel.setDescription(\"music channel hosted by coffee-thoughts\"); channel.setLightColor(Color.GREEN); channel.setLockscreenVisibility(Notification.VISIBILITY_PUBLIC); notificationManager.createNotificationChannel(channel);&#125; Here is the kotlin implementation 123456789val notificationManager = getSystemService(Service.NOTIFICATION_SERVICE) as? NotificationManagernotificationManager?.createNotificationChannel( NotificationChannel(CHANNEL_ID, CHANNEL_NAME, NotificationManager.IMPORTANCE_DEFAULT).apply &#123; enableLights(true) name = \"uptown\" description = \"music channel hosted by coffee-thoughts\" lightColor = Color.GREEN lockscreenVisibility = Notification.VISIBILITY_PUBLIC &#125;) The kotlin version has 1 line less of code? Hooray!Well, when I use concise as the section title here, I didn‚Äôt really mean the number of lines code though. The kotlin implementation does have less code to write, but I won‚Äôt expect to use that to convince other folks to try out a new language. (If you do get convinced by this reason, let me know, I‚Äôll still cheer for myself üçª) Some differences from above examples, in kotlin‚Äôs implementation set methods get replaced with kotlin generated synthetic properties scope function apply eliminates intermediate local variables as? safe type casting &amp; ?. if-not-null shorthand removes if-null checks If you know/familiar with kotlin syntax (if you‚Äôre not, leave out those syntax thing while reading), compared to java, kotlin code is much easier to read and understand, as there‚Äôre less noises and the control/execution flow is more intuitive logically. The bare-bone structure of above example is 1notificationManager.createNotification(customized_notification_channel_instance) For the kotlin implementation, you would know what the code snippet is trying to do after the first two lines of the code but not for the java one. Kotlin is able to express above flow as expected while in java implementation, the notificationManager instance and its method call of createNotification just got cut off, you could workaround it by extracting it into helper function, but it‚Äôs just not something you get out of box. Nullable &amp; its NPEIf you‚Äôre from the realm of java, you may share the same felling for the everywhere null checks and its sibling NPEs (the billion-dollar mistake). We have code review, Nullable, NonNull annotations to help, but developers usually ignore the lint warnings from IDE (it‚Äôs just a warning, what could go wrong, right?), the fact is just that people are bad at following rules, but computer does this better, so kotlin makes nullability into its type system. Think about it, String and nullable string String? are two different types #mindblowing 12345var iKnowVarIsNeverNull = \"default val\"iKnowVarIsNeverNull = null // compile errorvar expectNullableVal :String? = \"\"expectNullableVal = null // okay How this gonna change our programming mental model? Let‚Äôs continue our demo of music player by building album root by iterating media metadata. The simplified java implementation is as below, for each media metadata, it creates an album out of it and adds it to media root directory. 1234567891011121314151617181920212223242526272829/** * Builds a node, under the root, that represents an album, given * a [MediaMetadataCompat] object that's one of the songs on that album, * marking the item as [MediaItem.FLAG_BROWSABLE], since it will have child * node(s) AKA at least 1 song. */List&lt;MediaMetadataCompat&gt; buildAlbumRoot(@NonNull MediaMetadataCompat mediaMetadata) &#123; // 1. precondition check to make sure it's not null or lets hope null var is not passed in Preconditions.isNotNull(mediaMetadata); MediaMetadataCompat.Builder metaBuilder = new MediaMetadataCompat.Builder(); String albumUri = mediaMetadata.getAlbumUri(); // 2. defensive null-check (`setAblumUri` is a helper method only accepts non-null string) if (albumUri != null) &#123; metaBuilder.setAlbumUri(albumUri); &#125; final MediaMetadataCompat albumMetadata = metaBuilder.build(); // 3. create the root if it does not exist yet List&lt;MediaMetadataCompat&gt; rootList = mediaIdChildren.get(BROWSABLE_ROOT); if (rootList == null) &#123; rootList = new ArrayList&lt;&gt;(); &#125; rootList.add(albumMetadata); mediaIdChildren.put(BROWSABLE_ROOT, rootList); // generate &amp; return album list&#125; There‚Äôre one precondition check, two places of null-checks, from both defensive programming and inevitable list initialization (comment #3), we probably see similar code everyday if you‚Äôre coding in java. Is kotlin able to ease this pain? Here is the kotlin version implementing the same functionality 12345678910111213fun buildAlbumRoot(mediaItem: MediaMetadataCompat): MutableList&lt;MediaMetadataCompat&gt; &#123; val albumMetadata = MediaMetadataCompat.Builder().apply &#123; albumArtUri = mediaItem.albumArtUri?.toString() // other attributes settings &#125;.build() // Ensure the root node exists and add this album to the list. val rootList = mediaIdToChildren[BROWSABLE_ROOT] ?: mutableListOf() rootList += albumMetadata mediaIdToChildren[BROWSABLE_ROOT] = rootList // generate &amp; return album list&#125; In kotlin, we removed @NonNull annotation and its precondition check, we‚Äôre less paranoid about the argument nullability since we know that MediaMetadataCompat type (different from MediaMetadataCompat? remember?) is not-null by its nature, and the type system would do compile checks on it! Code flow is much less distracted when working with nullability, if-null and if-not-null get replaced by ?. and ?: syntax sugar, small thing like this really makes a huge difference on readability. Cheatsheet on working with nullability Kotlin operators Snippet elvis operator ?:, if receiver is not null use it, otherwise, use the latter return nullable_var ?: &quot;default&quot; safe call ?., execute and return var.length if not null, otherwise return null nullable_var?.length safe (nullable) cast as?, avoiding ClassCastException if cast fails nullable_var as? expected_type non-null assertion !! (also known as hold my beer operator), use the var as not-null even though it‚Äôs not from its type nullable_var!!.i_am_not_drunk() cope with scope functions (let, apply, also, etc), execute block when not null nullable_var?.let { } ExtensionsI work with iOS sometimes, among all the weirdness of objective-c, one thing I enjoy a lot is the ability to use extensions. Extension function description from kotlin site. Kotlin, similar to C# and Gosu, provides the ability to extend a class with new functionality without having to inherit from the class or use any type of design pattern such as Decorator. This is done via special declarations called extensions. Kotlin supports extension functions and extension properties. This feature is extremely useful when dealing with android, java or 3rd party sdk apis where you don‚Äôt have full control over. We‚Äôre good at creating util classes to wrap common operations on external objects, or inherit from its parent and adding more seasoning there (using inheritance with great caution). But with the help of kotlin, most of the these tasks could be done quite differently, in a happy way.If we need to convert a list of string to a list of integer, in java, We might have a ListUtil class, iterating string in the list and generate a list of integers, the method call would be like ListUtils.toIntList(string_list). With kotlin, the transform could be implemented as below 1fun List&lt;String&gt;.toIntList() = map &#123; it.toInt() &#125; and you may just call string_list.toIntList() as if toIntList() is one of List&lt;String&gt; natively supported method, the syntax is more intuitive and no extra arguments passing is needed. Above implementation also uses lambda and kotlin‚Äôs single-expression function, hopefully it‚Äôs not confusing, checkout common kotlin idioms for more info. Android supportKotlin is first-class programming language for android, the tools, libs behind it are well supported by google. Android KTX is a set of kotlin extensions that optimizes android platform apis for kotlin use, they try hard to make sure developers have a pleasant experiences ;) As an android developer, google got your back. There‚Äôre some neat kotlin+ktx examples from google developer site, go and check it out. Kotlin pandora boxAfter reading &amp; coding more with kotlin, I decide to add this section here, as a memo to myself or to anyone who might fall into this fantasy. I‚Äôll keep a list of code idioms/snippets what I consider bad and should avoid in the future. Even though we all love conciseness, readability is always more important, do not sacrifice that when working with a language like kotlin, applying all those fancy syntax and making others lost. It‚Äôs fun to write kotlin code, however please make sure we‚Äôre writing readable &amp; maintainable code for others (and future you), code-review-with-beer is our goal ;) DO NOT abuse scope functionsSwap vars using also scope functions 1234// swap two variables, a and b hereval a = 1val b = 2a = b.also &#123; b = a &#125; Avoid java style multi-line operationsIn java, lots of people would make long single-line operations into smaller chunks by splitting it into multiple lines, this won‚Äôt work well in kotlin, as statement is line-based instead of comma based in kotlin, this is something we need to be aware of. Let‚Äôs run through examples below 123456789101112131415// multi-line operations are not the same in java// below two values are actually differentval testVal = 1 + 2 // 3 - expected// Bad / Wrong - the second line would just be ignored and no lint warnings generatedval multiLineVal = 1 + 2 // multilLineVal is evaluated as 1// But if you lift the operator up to the first line, it would produce 3, hmmm..val multiLineVal = 1 + 2 // multiLineVal is 3// Or wrapping the statement in ()val multiLineVal = (1 + 2) // produce 3 As it is way too easy to make mistakes, I would simply recommend to avoid this type of style until we have better IDE supports in the future. I‚Äôm so glad and you read till here, if you ever feel tired of coding java but still love the ecosystem, try out kotlin (kotlin is 100% interoperable with java and it‚Äôs way beyond that), it might be a good fit for you. There‚Äôre lots of other syntax sugar and language features I‚Äôm not covering here, such as data class, string interpolation, lazy properties, delegation, coroutines, etc. The official kotlin reference has always been helpful to me, start from there if you want to explore more. #Happy coding","categories":[],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://github.com/chuangx/tags/kotlin/"}]},{"title":"IPC in Android","slug":"IPC-in-Android","date":"2019-03-01T11:32:04.000Z","updated":"2019-05-08T09:32:58.349Z","comments":true,"path":"2019/03/01/IPC-in-Android/","link":"","permalink":"https://github.com/chuangx/2019/03/01/IPC-in-Android/","excerpt":"What IPC (inter-process communication) mechanisms are commonly used in android, and how does it work under the hood? IPC typically gets ignored by app developers as it is so well encapsulated by android system so that we don‚Äôt need to care about it (i lied about this part - we‚Äôll talk about this later in this article). But IPC actually runs everywhere from app starts to any interactions to system or third party apps, so how the magic works?","text":"What IPC (inter-process communication) mechanisms are commonly used in android, and how does it work under the hood? IPC typically gets ignored by app developers as it is so well encapsulated by android system so that we don‚Äôt need to care about it (i lied about this part - we‚Äôll talk about this later in this article). But IPC actually runs everywhere from app starts to any interactions to system or third party apps, so how the magic works? Well, first all, let‚Äôs warm up a bit, what IPC mechanisms are supported by linux? We have signals, pipes, sockets, message queues, semaphores and shared memory, etc. On android, the underlying mechanisms are still the same, but it‚Äôs presented quite differently to developers, let‚Äôs quickly run through tasks below Share text through system action sheet - startActivity(Intent.createChooser(intent_data)) Start a foreground service to play music - startService(Intent(this, MusicService::class.java)) Retrieve contacts from phone app by using content provider Send &amp; handle broadcast event Above scenarios cover the 4 fundamental components in android. For the first one, when we make startActivity call to share content through intent to another app, how is the data being passed around? Apps are running in its separate processes, so IPC is clearly involved in this (same applies to the rest 3 examples above), let‚Äôt dive into this. I‚Äôll come back to this when I have more time, stay tuned.","categories":[],"tags":[]},{"title":"Evolving of android threading & background tasks","slug":"Development-of-background-tasks-in-android","date":"2018-06-05T04:01:53.000Z","updated":"2019-05-08T08:09:39.076Z","comments":true,"path":"2018/06/05/Development-of-background-tasks-in-android/","link":"","permalink":"https://github.com/chuangx/2018/06/05/Development-of-background-tasks-in-android/","excerpt":"ËøôÁØáÊñáÁ´†‰∏ªË¶ÅÂ§ßËá¥ËÆ≤Ëß£Âú®android‰∏äÂÆûÁé∞ÂêéÂè∞‰ªªÂä°ÁöÑÂá†ÁßçÊñπÊ≥ïÔºåÂÆÉ‰ª¨‰πãÈó¥ÁöÑÂå∫Âà´‰ª•ÂèäÂºÄÂèë‰∏≠ÁöÑÊúÄ‰Ω≥ÂÆûË∑µ„ÄÇÂêéÂè∞‰ªªÂä° (background tasks/operations) ÊòØ‰∏Ä‰∏™ÂæàÂÆΩÊ≥õÁöÑÊ¶ÇÂøµÔºåÂú®android‰∏äÊàë‰ª¨ÈÄöÂ∏∏ÊåáÈùû‰∏ªÁ∫øÁ®ãÁöÑ‰ªªÂä°Ôºå‰æãÂ¶ÇÁΩëÁªúÊìç‰ΩúÔºåËØªÂÜôÊï∞ÊçÆÂ∫ìÔºèÊñá‰ª∂ÊàñÊòØÂÆöÊó∂‰ªªÂä°Á≠âÁ≠âÔºåËøô‰∫õ‰ªªÂä°ÈÄöÂ∏∏ËÄóÊó∂ËæÉ‰πÖÂõ†ËÄåÈúÄË¶ÅÂºÇÊ≠•Â§ÑÁêÜ„ÄÇAndroidÁªôÂºÄÂèëËÄÖÊèê‰æõ‰∫ÜÂæàÂ§ö‰∏çÂêåÁöÑapiÊù•ÂÅöËøô‰ª∂‰∫ãÊÉÖÔºåÊØîÂ¶ÇAsyncTask, Loader, IntentService, JobIntentService, AlarmManager, JobDispatcher, JobScheduler, WorkManager‚Ä¶ ahÔºåÈô§‰∫Ü‰ª•‰∏äËøô‰∫õÔºåÊàë‰ª¨ËøòÊúârxjava (the list might keep growing)","text":"ËøôÁØáÊñáÁ´†‰∏ªË¶ÅÂ§ßËá¥ËÆ≤Ëß£Âú®android‰∏äÂÆûÁé∞ÂêéÂè∞‰ªªÂä°ÁöÑÂá†ÁßçÊñπÊ≥ïÔºåÂÆÉ‰ª¨‰πãÈó¥ÁöÑÂå∫Âà´‰ª•ÂèäÂºÄÂèë‰∏≠ÁöÑÊúÄ‰Ω≥ÂÆûË∑µ„ÄÇÂêéÂè∞‰ªªÂä° (background tasks/operations) ÊòØ‰∏Ä‰∏™ÂæàÂÆΩÊ≥õÁöÑÊ¶ÇÂøµÔºåÂú®android‰∏äÊàë‰ª¨ÈÄöÂ∏∏ÊåáÈùû‰∏ªÁ∫øÁ®ãÁöÑ‰ªªÂä°Ôºå‰æãÂ¶ÇÁΩëÁªúÊìç‰ΩúÔºåËØªÂÜôÊï∞ÊçÆÂ∫ìÔºèÊñá‰ª∂ÊàñÊòØÂÆöÊó∂‰ªªÂä°Á≠âÁ≠âÔºåËøô‰∫õ‰ªªÂä°ÈÄöÂ∏∏ËÄóÊó∂ËæÉ‰πÖÂõ†ËÄåÈúÄË¶ÅÂºÇÊ≠•Â§ÑÁêÜ„ÄÇAndroidÁªôÂºÄÂèëËÄÖÊèê‰æõ‰∫ÜÂæàÂ§ö‰∏çÂêåÁöÑapiÊù•ÂÅöËøô‰ª∂‰∫ãÊÉÖÔºåÊØîÂ¶ÇAsyncTask, Loader, IntentService, JobIntentService, AlarmManager, JobDispatcher, JobScheduler, WorkManager‚Ä¶ ahÔºåÈô§‰∫Ü‰ª•‰∏äËøô‰∫õÔºåÊàë‰ª¨ËøòÊúârxjava (the list might keep growing) AsyncTaskÂá∫Áé∞Âú®API 3‰∏≠ÔºåÁõ∏‰ø°Â§ßÂÆ∂Âú®androidÂºÄÂèëÁöÑÂàùÊúüÂ∞±Â∑≤ÁªèÊé•Ëß¶Ëøá‰∫Ü„ÄÇ‰∏Ä‰∏™ÊúâË∂£ÁöÑ‰∫ãÊÉÖÊòØAsyncTaskÊúÄÂàùËÆæËÆ°ÊòØÂú®‰∏Ä‰∏™ÂêéÂè∞Á∫øÁ®ã‰∏ä‰∏≤Ë°åÊâßË°åÊâÄÊúâÁöÑ‰ªªÂä°ÔºåÂú®API 4‰∏≠‰∏∫‰∫ÜÊèêÂçáÊïàÁéáÂèòÊàê‰∫ÜÂ§öÁ∫øÁ®ãÂπ∂Ë°åÂ§ÑÁêÜÔºå2Âπ¥‰πãÂêéÂú®android 3.0 (API 11) Âõ†‰∏∫ÊúâÂ§™Â§öÂ∫îÁî®Âπ∂ÂèëÈîôËØØ‰∏≠ÂèàÊîπÂõû‰∫ÜÈªòËÆ§ÂçïÁ∫øÁ®ã‰∏≤Ë°åÂ§ÑÁêÜ :shrugAsyncTaskÁöÑÂá∫Áé∞ÊòØ‰∏∫‰∫ÜÁÆÄÂåñandroid‰∏äÂêéÂè∞Á∫øÁ®ãÂ§ÑÁêÜ‰ª•ÂèäÂíå‰∏ªÁ∫øÁ®ãÁöÑÈÄö‰ø°Ôºå‰ΩÜÊòØÊúâ‰∏Ä‰∏™ÈóÆÈ¢òÊòØÂÆÉÂπ∂‰∏çËÉΩÂæàÂ•ΩÁöÑÂ§ÑÁêÜ activity/fragment ÁöÑÁîüÂëΩÂë®Êúü„ÄÇ‰∏Ä‰∏™Êàë‰ª¨ÁªèÂ∏∏ÈÅáÂà∞ÁöÑÈóÆÈ¢òÂ∞±ÊòØÁî®Êà∑ÊóãËΩ¨Â±èÂπï‰πãÂêéÔºåÂΩìÂâçactivityË¢´ÈáçÊñ∞ÂàõÂª∫Ôºå‰ΩÜÊòØAsyncTask‰ºöÁªßÁª≠ËøêË°åÂπ∂ÊåÅÊúâÂâç‰∏Ä‰∏™activityÁöÑreferenceÔºåËøôÊ†∑‰∏ç‰ªÖÂØºËá¥Ââç‰∏Ä‰∏™activityÊ≤°ÊúâÂäûÊ≥ïË¢´Á´ãÂàªÈîÄÊØÅÔºåËÄå‰∏îonPostExecuteÂØπUIÁöÑÊõ¥Êñ∞‰ºöÊ≤°ÊúâÊïàÊûúÂõ†‰∏∫ÂÖ∂Â∞ùËØïÊõ¥Êñ∞ÁöÑÊòØÂâç‰∏Ä‰∏™activity„ÄÇÊâÄ‰ª•Êàë‰ª¨ÁªèÂ∏∏ÈúÄË¶ÅÂØπAsyncTaskÂÅöÈ¢ùÂ§ñÁöÑÁîüÂëΩÂë®ÊúüÁÆ°ÁêÜÔºåÊØîÂ¶ÇÂú®activity#onStop‰∏≠ÂéªÂèñÊ∂àÊâÄÊúâËøòÊ≤°ÊúâÁªìÊùüÁöÑAsyncTaskÔºåÔºàÂΩìÁÑ∂‰Ω†ÂèØ‰ª•ÈÄöËøáÈòªÊ≠¢activity/fragmentÁöÑÊñ∞Âª∫ÂéªËß£ÂÜ≥Ëøô‰∏™ÈóÆÈ¢ò, but it‚Äôs really a terrible idea, think twice before doing anything like that)„ÄÇÈöè‰πãËÄåÊù•ÁöÑÂè¶‰∏Ä‰∏™ÂùëÂ∞±ÊòØAsyncTask#cancel is best effort, ËÄå‰∏îcancelÂπ∂‰∏ç‰ºöÁ´ãÂàª ÈòªÊñ≠doInBackgroundÁöÑ‰ªªÂä°ÊâßË°åÔºå ÊâÄ‰ª•Êàë‰ª¨ÈúÄË¶Å‰∏çÊñ≠Ê£ÄÊü•isCancelled Á°Æ‰øù‰ªªÂä°ÂèØ‰ª•Â∞ΩÂø´ÂèñÊ∂àÊéâ„ÄÇÂ¶ÇÊûú‰Ω†ÊÉ≥Ë¶Å‰∫ÜËß£ÁöÑÊõ¥Â§öAsyncTaskÁöÑÈóÆÈ¢òÔºåDan Lew ÁöÑËøôÁØáÊñáÁ´†ÊúâÊõ¥Ê∑±ÂÖ•ÁöÑËÆ≤Ëß£„ÄÇhttp://blog.danlew.net/2014/06/21/the-hidden-pitfalls-of-asynctask/blog.danlew.net AsyncTaskÁöÑËøô‰∫õÁº∫ÁÇπÁ°ÆÂÆûÁªôÊàë‰ª¨Â∏¶Êù•‰∫ÜÂæàÂ§öboilerplate codeËÄå‰∏î‰∏Ä‰∏çÂ∞èÂøÉÂ∞±ÂÆπÊòìÂá∫ÈîôÔºåÊàë‰∏ÄËà¨Âè™ÊúâÂú®ÂºÇÊ≠•Êìç‰ΩúÊª°Ë∂≥‰ª•‰∏ãÊù°‰ª∂ÁöÑÊó∂ÂÄô‰ºö‰ΩøÁî®AsyncTask: Simple and quick operations - to avoid blocking other possible async tasks as it‚Äôs running in serial by default No UI update involved - to avoid extra lifecycle management Killable - the task can be killed/cancelled if necessary Â¶ÇÊûúÊòØÊª°Ë∂≥‰∏äËø∞‰∏â‰∏™Êù°‰ª∂ÁöÑÊìç‰ΩúÁöÑËØùÔºåÊàë‰ª¨ÂèØ‰ª•Áõ¥Êé•‰ΩøÁî®AsyncTask.execute(Runnable r) Â∞±ÂèØ‰ª•‰∫ÜÔºåe.g. ÂºÇÊ≠•Ëé∑ÂèñÊõ¥Êñ∞ËÆæÂ§áÁöÑad info AdvertisingIdClient.getAdvertisingIdInfo. ÂÖ∂ÂÆûLoaderÁöÑÂá∫Áé∞(API 11)Êú¨Êù•Â∞±ÊòØ‰∏∫‰∫ÜËß£ÂÜ≥‰∏äÈù¢ÊèêÂà∞ÁöÑAsyncTask lifecycleÈóÆÈ¢òÔºåAsyncTaskLoaderÊòØLoaderÁöÑ‰∏Ä‰∏™ÂÆûÁé∞Ôºå‰ªéÂêçÂ≠ó‰∏≠‰πüÂèØ‰ª•ÁúãÂá∫ËÆæËÆ°ÁöÑÂàùË°∑„ÄÇ‰ΩÜÊòØ‰πüÊúâÂæàÂ§öÁº∫Èô∑‰∏ÄÁõ¥Ë¢´ÂºÄÂèëËÄÖÊä±ÊÄ®Ôºåconfusing api, testability and boilerplate code, etc. Âú®API 28‰∏≠ÔºåLoaderÂ∑≤Ë¢´ÂÆòÊñπdeprecatedÔºåÊé®Ëçê‰ΩøÁî® ViewModel + LiveData. Loaders have been deprecated as of Android P (API 28). The recommended option for dealing with loading data while handling the Activity and Fragment lifecycles is to use a combination of ViewModels and LiveData. ViewModels survive configuration changes like Loaders but with less boilerplate. LiveData provides a lifecycle-aware way of loading data that you can reuse in multiple ViewModels.If you‚Äôve never used loader before, congrats, time to go with architecture component directly! ServiceÂú®ÂêéÂè∞‰ªªÂä°Â§ÑÁêÜ‰∏≠ÂèàÊâÆÊºî‰∫ÜÊÄéÊ†∑ÁöÑ‰∏Ä‰∏™ËßíËâ≤Âë¢ÔºüServiceËÆæËÆ°‰πãÂàùÂ∞±ÊòØ‰∏∫‰∫ÜÂèØ‰ª•Âú®ÂêéÂè∞ÊâßË°ålong-running operations, ‰∏Ä‰∏™Â∏∏ËßÅÁöÑËØØËß£Â∞±ÊòØServiceÂ∞±ÊòØËøêË°åÂú®background thread‰∏äÁöÑÔºåÊàëÊÉ≥ÂÖ∂‰∏≠‰∏ÄÂ§ßÂéüÂõ†Â∞±ÊòØÊù•Ëá™ServiceÁöÑÂÆö‰πâÔºåbackground + long-running operationsÂæàÂÆπÊòìÁªô‰∫∫ÊúâÈîôËØØÁöÑÂÅáÂÆö„ÄÇ A Service is an application component that can perform long-running operations in the background, and it doesn‚Äôt provide a user interface. ServiceÈªòËÆ§ËøêË°åÂú®ÂΩìÂâçÂ∫îÁî®ËøõÁ®ãÁöÑ‰∏ªÁ∫ø‰∏≠ÔºåÊâÄ‰ª•Â¶ÇÊûúÈúÄË¶ÅÊâßË°åblocking or intensive work (different from long-running operations)ÔºåÊàë‰ª¨ËøòÊòØÈúÄË¶ÅËá™Â∑±ÂàõÂª∫Êñ∞ÁöÑËøõÁ®ã„ÄÇ‰∏∫‰∫ÜÊñπ‰æøÂºÄÂèëÔºåAndroidÂÆûÁé∞‰∫ÜIntentServiceÔºåÂÆÉÈÄöËøá‰∏Ä‰∏™ÂêéÂè∞Á∫øÁ®ãÂéªÂ§ÑÁêÜÊâÄÊúâÁöÑ‰ªªÂä°ËØ∑Ê±ÇÔºåÈúÄË¶ÅÊ≥®ÊÑèÁöÑÊòØ‰ªªÂä°ÁöÑÂ§ÑÁêÜÊòØ‰∏≤Ë°åÁöÑ„ÄÇÈÇ£‰πàIntentServiceÊàñÊòØÈÄöËøáServiceÂÆûÁé∞ÁöÑÂÖ∂ÂÆÉÂêéÂè∞‰ªªÂä°Â§ÑÁêÜÂíåAsyncTaskÊàñÊòØThreadÁöÑÂå∫Âà´ÊòØ‰ªÄ‰πàÂë¢ÔºüËôΩÁÑ∂ÂÆÉ‰ª¨Êú¨Ë¥®‰∏äÈÉΩÊòØÂØπThreadÁöÑÂ∞ÅË£ÖÔºå‰ΩÜÊòØÂÆÉ‰ª¨ÊúâÂÆåÂÖ®‰∏çÂêåÁöÑËÆæËÆ°ÂàùË°∑„ÄÇÂØπ‰∫éAsyncTaskËÄåË®ÄÔºåÊõ¥Â§öÁöÑÂíåActivity/UIÂÖ≥ËÅîÔºåËÄå‰∏î‰ªªÂä°Â§ÑÁêÜÈÄöÂ∏∏ÊòØË¶ÅÊ±ÇÂæàÁü≠ÔºåËÄåServiceÊõ¥Â§öÁöÑÊòØÂú®Â∫îÁî®Â§Ñ‰∫éÂêéÂè∞ÔºàÊ≤°ÊúâÁî®Êà∑‰∫§‰∫íÊàñÊòØUIÊõ¥Êñ∞ÔºâÊó∂ÂèëÊå•‰ΩúÁî®ÔºåËÄå‰∏îÂú®‰ªªÂä°Ê≤°ÊúâÂÆåÊàê‰πãÂâçÔºåServiceÂèØ‰ª•Ë¶ÅÊ±ÇÂú®Á≥ªÁªüËµÑÊ∫êÂÖÖË∂≥Êó∂ÈáçÂêØ„ÄÇJobIntentServiceÂèàÊòØÊÄé‰πà‰∏ÄÂõû‰∫ãÔºü Ëøô‰∫õÁºòËµ∑‰∫éAndroidÂØπÂêéÂè∞‰ªªÂä°ÁöÑÈôêÂà∂Âíå‰ºòÂåñ„ÄÇÊàë‰ª¨‰πãÂêéÂú®ÂêéÂè∞‰∏ÄÁõ¥ËøêË°åServiceÂÖ∂ÂÆûÂæàÂêÉÁ≥ªÁªüËµÑÊ∫êÔºåÁâπÂà´ÊòØÊúâ‰∏çÂ∞ëÊó†ËâØApp‰ºöÈÄöËøáServiceÂ∏∏È©ªÂêéÂè∞ÔºåÁªôÁî®Êà∑Â∏¶Êù•‰∫ÜÂæàÂ∑ÆÁöÑÁî®Êà∑‰ΩìÈ™å„ÄÇÊâÄ‰ª•Android NÔºàAndroid 7.0ÔºâÂíå Android OÔºàAndroid 8.0ÔºâÁ≥ªÁªüÂØπBackground ServiceÂíåBroadcastÂÅö‰∫Ü‰∏ÄÂÆöÁöÑÈôêÂà∂ÔºåÂÖ∂‰∏≠ÁöÑ‰∏Ä‰∫õÈôêÂà∂ÂåÖÊã¨Ôºö‰∏çÂèØ‰ª•Âú®Â∫îÁî®Â§Ñ‰∫éÂêéÂè∞Áä∂ÊÄÅÊó∂call startServiceÂêØÂä®ServiceÔºåIllegalStateException will be thrown otherwiseÂΩìÂ∫îÁî®ÈÄÄÂà∞ÂêéÂè∞‰πãÂêéÔºåÁ≥ªÁªü‰ºöÁªôÂ∫îÁî®Âá†ÂàÜÈíüÂ∑¶Âè≥ÁöÑÊó∂Èó¥ÁªßÁª≠ËøêË°å‰πãÂâçÊâÄÂàõÂª∫ÂêØÂä®ÁöÑÂêéÂè∞ÊúçÂä°Ôºå‰πãÂêé‰æø‰ºöË¢´Á≥ªÁªüÊ†áËÆ∞‰∏∫Á©∫Èó≤Áä∂ÊÄÅÔºåÂπ∂ÂÅúÊ≠¢ËØ•ÂêéÂè∞ÊúçÂä°„ÄÇ Above limitations are only background service as foreground service is more visible to users. ÂØπ‰∫éBroadcastÁöÑÈôêÂà∂ÂåÖÊã¨Ôºö Android 7.0 ‰∏≠Ôºåapp can NOT send or receive ACTION_NEW_PICTURE or ACTION_NEW_VIDEO broadcast App targeting Android 7.0 and higher can‚Äôt receive CONNECTIVITY_ACTION if it‚Äôs declared in manifest From Android OÔºåall implicit broadcast receivers declared in manifest file will not work Ëøô‰πàÂÅöÁöÑÂéüÂõ†ÂæàÁÆÄÂçïÔºåÂõ†‰∏∫implicit broadcastÊòØ‰∏Ä‰∏™ÂæàÊµ™Ë¥πÁ≥ªÁªüËµÑÊ∫êÁöÑ‰∫ãÊÉÖ„ÄÇÊØîÂ¶ÇÊúâ10‰∏™Â∫îÁî®Ê≥®ÂÜåÂπ∂ÁõëÂê¨‰∫ÜËøô‰∏™CONNECTIVITY_ACTIONËøô‰∏™ÂπøÊí≠ÔºåÂΩìÁî®Êà∑ÊâãÊú∫ÁöÑÁΩëÁªúËøûÊé•ÂèëÁîüÂèòÂåñÊó∂ÔºåËøô10‰∏™Â∫îÁî®ÈÉΩ‰ºöË¢´Âî§Ëµ∑ÂéªÂ§ÑÁêÜËøô‰∏™‰∫ã‰ª∂Ôºå‰ΩÜÂèØËÉΩÂÖ∂‰∏≠90%ÁöÑÂ∫îÁî®Âè™ÂÖ≥ÂøÉÁî®Êà∑ÊòØÂê¶ËøûÊé•Âà∞wifi‰ª•‰æøÂêåÊ≠•Êï∞ÊçÆÔºåÈÇ£‰πàÂΩìÁî®Êà∑Â§±ÂéªÁΩëÁªúËøûÊé•ÊàñÊòØËøûÊé•Âà∞metered networkÊó∂ÔºåËøô‰∫õÂ∫îÁî®ÈÉΩË¢´‰∏çÂøÖË¶ÅÁöÑÂî§ÈÜí‰∫Ü„ÄÇ‰∏∫‰∫ÜËß£ÂÜ≥Ëøô‰∫õÈóÆÈ¢òÔºåÂπ∂ÁªôÂºÄÂèëËÄÖÊèê‰æõÊõ¥Âä†Êô∫ËÉΩÁöÑÂêéÂè∞‰ªªÂä°Â§ÑÁêÜÔºåAndroidÊèêÂá∫‰∫ÜJobÂíåJobSchedulerÁöÑÊ¶ÇÂøµÔºåÂú®‰∏ã‰∏ÄÁØáÊñáÁ´†‰∏≠Êàë‰ª¨Â∞Ü‰ºöÊúâËøõ‰∏ÄÊ≠•ÁöÑ‰∫ÜËß£„ÄÇ ‰∏ä‰∏ÄÁØáÊñáÁ´†‰∏≠Êàë‰ª¨Â§ßËá¥ËÆ≤Ëß£‰∫ÜAsyncTask, Loader, IntentServiceÁöÑÂå∫Âà´‰ª•ÂèäAPIÁöÑÊºîÂèòÂèëÂ±ïÔºå‰∏∫‰∫Ü‰ºòÂåñÂêéÂè∞‰ªªÂä°ÔºåÁªôÂºÄÂèëËÄÖÊèê‰æõÊõ¥Âä†Êñπ‰æøÊô∫ËÉΩÁöÑ‰ªªÂä°Â§ÑÁêÜÔºåAndroidÂú®5.0 (API 21)‰∏≠Êé®Âá∫‰∫ÜJobScheduler„ÄÇJobSchedulerÁöÑ‰∏ÄÂ§ß‰ºòÁÇπÂ∞±ÊòØÂÆÉÊòØÂü∫‰∫éÊù°‰ª∂ËÄåÈùûÊó∂Èó¥ËÄåËøõË°å‰ªªÂä°Â§ÑÁêÜÁöÑ„ÄÇ [ref https://medium.com/google-developers/scheduling-jobs-like-a-pro-with-jobscheduler-286ef8510129] (ËøôÁØáÊñáÁ´†ËÆ≤ÁöÑÂæàÊ£íÔºâ„ÄÇJobScheduler performs work based on conditions, not on time.ÈÄöËøáJobInfoÊàë‰ª¨ÂèØ‰ª•ÂæàÂÆπÊòìÂæóÈÖçÁΩÆÂêéÂè∞‰ªªÂä°ÊâÄÈúÄÁöÑÂêÑÁßçÊù°‰ª∂ ÔºåÊØîÂ¶ÇÁΩëÁªúÁ±ªÂûãÔºåÁ≥ªÁªüÊòØÂê¶Á©∫Èó≤Ôºå ÊòØÂê¶Âú®ÂÖÖÁîµÁ≠âÁ≠âÔºåÂú®Android 8.0 (API 26)‰∏≠ÔºåÊàë‰ª¨ËøòÂèØ‰ª•ËÆæÁΩÆÁîµÈáèÂíåÂ≠òÂÇ®ÂÆπÈáèÁöÑÈôêÂà∂„ÄÇ 12345678val jobScheduler = context.getSystemService(Context.JOB_SCHEDULER_SERVICE) as JobScheduler jobScheduler.schedule(JobInfo.Builder(JOB_ID, ComponentName(context, CustomJobService::class.java)) .setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED) // ËøûÊé•wifiÊó∂ .setRequiresDeviceIdle(true) // ÈúÄË¶ÅÁ≥ªÁªüÁ©∫Èó≤ .setRequiresCharging(true) // ËÆæÂ§áÂÖÖÁîµ‰∏≠ .setRequiresBatteryNotLow(true) // requires API 26 ÁîµÈáè .setRequiresStorageNotLow(true) // requires API 26 Â≠òÂÇ®ÂÆπÈáè .build()) JobSchdulerÈÄöËøáÂú®Á≥ªÁªüÁ∫ßÂà´ÂÆûÁé∞ÊâÄÊúâÂ∫îÁî®ÂêéÂè∞‰ªªÂä°ÁöÑÁªü‰∏ÄË∞ÉÂ∫¶ÔºåËøôÊ†∑Êàë‰ª¨Â∞±‰∏çÁî®ÈÄöËøáAlarmManager‰∏çÊñ≠Âî§Ëµ∑Â∫îÁî®ÂéªÊ£ÄÊü•Âπ∂ÊâßË°å‰ªªÂä°‰∫ÜÔºåÊûÅÂ§ßÁ®ãÂ∫¶‰∏äÁºìËß£‰∫ÜÁîµÈáèÁöÑÊçüËÄó„ÄÇÊàë‰ª¨ÊâÄÈúÄË¶ÅÊâßË°åÁöÑ‰ªªÂä°ÈÄöËøáJobServiceÊù•ÂÆûÁé∞ÔºåJobServiceÊòØ‰∏Ä‰∏™bound serviceÔºåÂè™‰∏çËøáÂÆÉÂÆûÁé∞Âú®Ëá™Â∑±ÁöÑIBinder‰ª•‰æøJobSchedulerËøõË°åÈÄö‰ø°„ÄÇÊàë‰ª¨Âè™ÈúÄË¶ÅÂÆûÁé∞Â¶Ç‰∏ã‰∏§‰∏™ÊñπÊ≥ïÂ∞±ÂèØ‰ª•‰∫Ü„ÄÇ 1234567891011121314151617/** * Êàë‰ª¨ÈúÄË¶ÅÂú®Ëøô‰∏™ÊñπÊ≥ïÂõûË∞É‰∏≠ÂºÄÂßã‰ªªÂä°„ÄÇ * ÂíåÂÖ∂ÂÆÉService‰∏ÄÊ†∑ÔºåÈªòËÆ§Âú®‰∏ªÁ∫øÁ®ãÊâßË°åÔºåÊâÄ‰ª•‰ªª‰ΩïÂèØËÉΩÈòªÂ°ûUIÁöÑÊìç‰ΩúÈÉΩÂ∫îËØ•ÈÄöËøáworker threadÂéªÊâßË°å„ÄÇ * * @param params ÂÖ≥‰∫éÂΩìÂâçjobÁöÑ‰∏Ä‰∫õ‰ø°ÊÅØ * @return true Â¶ÇÊûúÂΩìÂâçjobËøòÈúÄË¶ÅÊâßË°å‰∏ÄÊÆµÊó∂Èó¥ÔºàÊØîÂ¶ÇÂºÄÂêØ‰∫ÜÊñ∞ÁöÑÁ∫øÁ®ãÔºâ, Âèç‰πãreturn false */abstract fun onStartJob(params: JobParameters): Boolean/** * Âõ†‰∏∫JobServiceÊòØÂü∫‰∫éÊù°‰ª∂Ë∞ÉÂ∫¶ÁöÑÔºåÊâÄ‰ª•ÂΩìÊâÄÈúÄÁöÑÊù°‰ª∂‰∏çÂÜçÊª°Ë∂≥Êó∂ÔºåÁ≥ªÁªü‰æø‰ºöÈÄöËøáËøô‰∏™ÂõûË∞ÉÈÄöÁü•Êàë‰ª¨ÔºåÊàë‰ª¨ÈúÄË¶Å * Âú®Ëøô‰∏™ÊñπÊ≥ï‰∏≠ÂÅúÊ≠¢Ê≠£Âú®ÊâßË°åÁöÑ‰ªªÂä°Âπ∂ÂÆåÊàêÁõ∏Â∫îÁöÑ‰∏≠Êñ≠Â§ÑÁêÜ„ÄÇ * * @param params ÂÖ≥‰∫éÂΩìÂâçjobÁöÑ‰∏Ä‰∫õ‰ø°ÊÅØ, ÊØîÂ¶Çjob idÔºå‰ªªÂä°ÂÅúÊ≠¢ÂéüÂõ†Á≠âÁ≠â * @return true Â¶ÇÊûúÂΩìÂâç‰∏≠Êñ≠ÁöÑ‰ªªÂä°ÈúÄË¶ÅË¢´ÈáçÊñ∞Ë∞ÉÂ∫¶ÔºåÂèç‰πãreturn false */abstract fun onStopJob(params: JobParameters): Boolean ÊâÄ‰ª•Âú®Android L+ (5.0+ API 21+)ÂêéÔºåÊâÄÊúâÂ§çÊùÇÔºåÂë®ÊúüÊÄßÁöÑÂêéÂè∞‰ªªÂä°Êàë‰ª¨ÈÉΩÂèØ‰ª•ÈÄöËøáJobSchedulerÊù•ÂÆûÁé∞‰ª•ËææÂà∞Êõ¥Â•ΩÁöÑÊÄßËÉΩ„ÄÇWARNING - JobSchedulerÂú®API 21Âíå22‰∏≠ÊúâÂæàÂ§öbugÔºåÊâÄ‰ª•Â¶ÇÊûúÊàë‰ª¨Âú®production‰∏≠ÔºåÊúÄÂ•ΩÂú®API 23+‰πãÂêéÊâç‰ΩøÁî®JobScheduler„ÄÇËÆ≤Âà∞ËøôÔºåÂè¶‰∏Ä‰∏™Êàë‰ª¨ÈúÄË¶Å‰∫ÜËß£ÁöÑÈÉ®‰ª∂Â∞±ÊòØJobDispatcherÔºåÂÆÉÁöÑÂ≠òÂú®Â∞±ÊòØ‰∏∫‰∫ÜÂÆûÁé∞JobSchedulerÁöÑÂêëÂêéÂÖºÂÆπ (ÊúÄ‰ΩéÊîØÊåÅ API 14)„ÄÇJobDispatcherÊù•Ëá™‰∫éFirebaseÔºåÂÆÉËÆæËÆ°‰∫ÜÂíåJobSchedulerÁ±ª‰ººÁöÑAPIÔºåÂú®Android L+ÁöÑÁ≥ªÁªü‰∏≠ÔºåÂ∫ïÂ±ÇÁöÑÂÆûÁé∞Â∞±ÊòØJobScheduler„ÄÇÂú®Android L‰πãÂâçÁöÑÁ≥ªÁªü‰∏≠ÔºåÂÆÉÈÄöËøá‰ΩøÁî®Google Play ServiceÊù•ÂÖÖÂΩìÁªü‰∏ÄË∞ÉÂ∫¶ËÄÖÁöÑËßíËâ≤ÔºåËøô‰πüÂ∞±ÊÑèÂë≥ÁùÄÈúÄË¶ÅËÆæÂ§áÂÆâË£ÖGMSÊâçÂèØ‰ª•ÔºåÂØπ‰∫éÂõΩÂÜÖÁöÑÁî®Êà∑Êù•ËØ¥ÔºåÊàë‰ª¨‰πüÂ∞±Âè™ÈúÄË¶Å‰∫ÜËß£‰∏Ä‰∏ãÂ∞±Â•Ω‰∫ÜÔºåÂèç‰πã‰πü‰∏çÂ§ßÁî®Âæó‰∏ä :(WorkManager ÊòØ‰ªäÂπ¥IOÊé®Âá∫ÁöÑÊñ∞ÁöÑAPIÔºåÊúÄÁÆÄÂçïÁöÑÊ¶ÇÊã¨Â∞±ÊòØÂÆÉÊòØÂØπÊàë‰ª¨‰πãÂâçÊèêÂà∞ÁöÑJobScheduler, JobDispatcher, AlarmManagerÁöÑÂè¶‰∏ÄÂ±ÇÂ∞ÅË£ÖÔºåÂÆÉ‰ºöÊ†πÊçÆ‰∏çÂêåÁ≥ªÁªüÈÄâÊã©ÂêàÈÄÇÁöÑÂÆûÁé∞ÊñπÂºè„ÄÇÂΩìÁÑ∂ÂÆÉËøòÁªôÊàë‰ª¨Êèê‰æõ‰∏Ä‰∫õÂÖ∂ÂÆÉÁöÑÂäüËÉΩÔºåÊØîÂ¶ÇÊõ¥Âä†ÁÅµÊ¥ªÁöÑ‰ªªÂä°Ë∞ÉÂ∫¶chain jobsÔºåi.e. WorkManager.getInstance().beginWith(A, B).then(C).then(D).enqueue()„ÄÇ 123456789101112131415161718192021222324252627282930313233static @NonNull Scheduler createBestAvailableBackgroundScheduler(@NonNull Context context) &#123; Scheduler scheduler; boolean enableFirebaseJobService = false; boolean enableSystemAlarmService = false; if (Build.VERSION.SDK_INT &gt;= WorkManagerImpl.MIN_JOB_SCHEDULER_API_LEVEL) &#123; scheduler = new SystemJobScheduler(context); setComponentEnabled(context, SystemJobService.class, true); Log.d(TAG, \"Created SystemJobScheduler and enabled SystemJobService\"); &#125; else &#123; try &#123; scheduler = tryCreateFirebaseJobScheduler(context); enableFirebaseJobService = true; Log.d(TAG, \"Created FirebaseJobScheduler\"); &#125; catch (Exception e) &#123; // Also catches the exception thrown if Play Services was not found on the device. scheduler = new SystemAlarmScheduler(context); enableSystemAlarmService = true; Log.d(TAG, \"Created SystemAlarmScheduler\"); &#125; &#125; try &#123; Class firebaseJobServiceClass = Class.forName(FIREBASE_JOB_SERVICE_CLASSNAME); setComponentEnabled(context, firebaseJobServiceClass, enableFirebaseJobService); &#125; catch (ClassNotFoundException e) &#123; // Do nothing. &#125; setComponentEnabled(context, SystemAlarmService.class, enableSystemAlarmService); return scheduler;&#125; SchedulerÊòØÁî®Êù•Ë∞ÉÂ∫¶Â∑•‰ΩúÁöÑinterfaceÔºå‰ªéüëÜÁöÑ‰ª£Á†ÅÊÆµ‰∏≠Êàë‰ª¨ÂèØ‰ª•ÁúãÂà∞WorkManagerÊòØÂ¶ÇÊûúÊ†πÊçÆÁ≥ªÁªüÊù°‰ª∂ÂàõÂª∫SchedulerÁöÑÔºåÁÆÄÊòìÁöÑÂÜ≥Á≠ñÂõæÂ¶Ç‰∏ã ÈúÄË¶ÅÊ≥®ÊÑèÁöÑÊòØWorkManagerÂíåService‰∏ÄÊ†∑ÔºåÊòØÁî®Êù•ÂÆûÁé∞ÈÇ£‰∫õÂç≥‰æøÂ∫îÁî®Ë¢´ÊùÄÊ≠ª‰πãÂêé‰ªçÈúÄÂÆåÊàêÁöÑ‰ªªÂä°„ÄÇÂØπ‰∫éÈÇ£‰∫õÂâçÂè∞ÁöÑËÄóÊó∂‰ªªÂä°ÔºåÊàë‰ª¨ÈúÄË¶ÅÈÄöËøáAnsycTaskÔºåThreadPoolÊù•ÂÆûÁé∞ÔºåËØ¶ÊÉÖÂèØ‰ª•ÈòÖËØªÂâç‰∏ÄÁØáÊñáÁ´†„ÄÇÂ∏åÊúõËøô‰∏§ÁØáÊñáÁ´†ËÉΩÂ§üÁªôÂ§ßÂÆ∂ÂØπandroidÂêéÂè∞‰ªªÂä°ÁöÑAPIÊºîÂèòÊúâ‰∏Ä‰∏™Â§ßËá¥ÁöÑ‰∫ÜËß£ÔºåÂπ∂Â≠¶‰ºöÊ†πÊçÆÈ°πÁõÆË¶ÅÊ±ÇÈÄâÊã©ÊúÄÂêàÈÄÇÁöÑÂÆûÁé∞„ÄÇ happy coding","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://github.com/chuangx/tags/android/"}]},{"title":"Backstack and task management for picture-in-picture on android O","slug":"Picture-in-picture-on-Android-O","date":"2018-03-26T08:05:46.000Z","updated":"2019-05-08T08:08:28.573Z","comments":true,"path":"2018/03/26/Picture-in-picture-on-Android-O/","link":"","permalink":"https://github.com/chuangx/2018/03/26/Picture-in-picture-on-Android-O/","excerpt":"","text":"This article was first published on medium in ProAndroidDev. I‚Äôm going do some editing and archive it here as well, stay tuned.","categories":[],"tags":[]}]}